1.类加载机制
https://www.cnblogs.com/ITtangtang/p/3978102.html
https://www.cnblogs.com/aspirant/p/7200523.html
https://blog.csdn.net/w8827130/article/details/82313612
https://www.cnblogs.com/codefeng/p/8598050.html

2.bean的声明周期
https://www.cnblogs.com/kenshinobiy/p/4652008.html
https://www.jb51.net/article/136825.htm

3.spring的bean在什么时候被实例化
Spring什么时候实例化bean，首先要分2种情况 
  第一：如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时候实例化 
  第二：如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况： 
       （1）：如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取 
       （2）：如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化 
       （3）：如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化

分类: Spring

4.Spring和Spring MVC包分开扫描原因
https://blog.csdn.net/l_d_y_k/article/details/78564224
首先配置的是Spring容器的初始化加载的application文件，然后是SpringMVC的前端控制器（DispatchServlet），当配置完DispatchServlet后会在Spring容器中创建一个新的容器。其实这是两个容器，Spring作为父容器，SpringMVC作为子容器。
注意:父容器不能访问子容器对象,而子容器可以访问父容器对象

5.nginx反向代理服务器实现负载均衡和动静分离
https://blog.csdn.net/qq_42342242/article/details/80639884
反向代理的作用

1、防止主服务器被恶意攻击

2、为负载均衡和动静分离提供实现支持

负载均衡：使用反向代理同时代理多个相同内容的应用服务器（比如tomcat），将客户端请求分发到各个应用服务器上并接收响应返回给客户端

负载均衡的作用：当一台服务器的单位时间内的访问量越大时，服务器压力就越大，大到超过自身承受能力时，服务器就会崩溃。为了避免服务器崩溃，让用户有更好的体验，我们通过负载均衡的方式来分担服务器压力。我们可以建立很多很多服务器，组成一个服务器集群，当用户访问网站时，先访问一个中间服务器，在让这个中间服务器在服务器集群中选择一个压力较小的服务器，然后将该访问请求引入该服务器。如此一来，用户的每次访问，都会保证服务器集群中的每个服务器压力趋于平衡，分担了服务器压力，避免了服务器崩溃的情况。

动静分离：运用Nginx的反向代理功能分发请求：所有动态资源的请求交给应用服务器，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器

动静分离的作用：主要是nginx处理静态页面的效率远高于tomcat的处理能力，使用c语言开发的nginx对静态资源每秒的吞吐量是使用Java语言开发的tomcat的6倍，也远高于其它应用服务器

总而言之：nginx应用之所以广泛，我认为这归功于它的灵活配置，一个nginx.conf文件解决大部分问题，不论是nginx创建虚拟服务器、nginx的反向代理服务器，还是nginx的负载均衡，几乎都在这个配置文件中进行。服务器上只负责把nginx搭好，跑起来即可。而且它本身轻量级，不需要占用服务器太多资源就可以达到较好的效果，是一个非常值得推崇的服务器。
--------------------- 
作者：qq_42342242 
来源：CSDN 
原文：https://blog.csdn.net/qq_42342242/article/details/80639884 
版权声明：本文为博主原创文章，转载请附上博文链接！

5.jvm虚拟机简介
https://www.cnblogs.com/enjiex/p/5079338.html
http://www.360doc.com/content/18/0801/23/54849_775027564.shtml

6.java编译器 java解释器 jvm
https://www.cnblogs.com/chengdabelief/p/6576320.html
JVM：JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。

Java编译器：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。

Java解释器：是JVM的一部分。Java解释器用来解释执行Java编译器编译后的程序。java.exe可以简单看成是Java解释器。

注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！


维基百科定义：

JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。

字节码：字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。

Java字节码：是Java虚拟机执行的一种指令格式。

解释器：是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快。

即时编译(Just-in-time compilation: JIT)：又叫实时编译、及时编译。是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。这项技术是被用来改善虚拟机的性能的。

JIT编译器是JRE的一部分。原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。

二进制文件：广义的二进制文件即为文件，由文件在外部存储设备的存放方式为二进制而得名。狭义的二进制文件即指除文本文件以外的文件。文本文件的格式包括：ASCII、MIME、txt。


7.java内存模型  
https://segmentfault.com/a/1190000014395186
JMM Java内存模型：
1、 Java的并发采用“共享内存”模型，线程之间通过读写内存的公共状态进行通讯。多个线程之间是不能通过直接传递数据交互的，它们之间交互只能通过共享变量实现。
2、 主要目的是定义程序中各个变量的访问规则。
3、 Java内存模型规定所有变量都存储在主内存中，每个线程还有自己的工作内存。
（1） 线程的工作内存中保存了被该线程使用到的变量的拷贝（从主内存中拷贝过来），线程对变量的所有操作都必须在工作内存中执行，而不能直接访问主内存中的变量。
（2） 不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递都要通过主内存来完成。
（3） 主内存主要对应Java堆中实例数据部分。工作内存对应于虚拟机栈中部分区域。

4、Java线程之间的通信由内存模型JMM（Java Memory Model）控制。
（1）JMM决定一个线程对变量的写入何时对另一个线程可见。
（2）线程之间共享变量存储在主内存中
（3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。
（4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。
5、可见性、有序性：
（1）当一个共享变量在多个本地内存中有副本时，如果一个本地内存修改了该变量的副本，其他变量应该能够看到修改后的值，此为可见性。
（2）保证线程的有序执行，这个为有序性。（保证线程安全）
6、内存间交互操作：
（1）lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。
（2）unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
（3）read（读取）：作用于主内存变量，把主内存的一个变量读取到工作内存中。
（4）load（载入）：作用于工作内存，把read操作读取到工作内存的变量载入到工作内存的变量副本中
（5）use（使用）：作用于工作内存的变量，把工作内存中的变量值传递给一个执行引擎。
（6）assign（赋值）：作用于工作内存的变量。把执行引擎接收到的值赋值给工作内存的变量。
（7）store（存储）：把工作内存的变量的值传递给主内存
（8）write（写入）：把store操作的值入到主内存的变量中
6.1、注意：
（1）不允许read、load、store、write操作之一单独出现
（2）不允许一个线程丢弃assgin操作
（3）不允许一个线程不经过assgin操作，就把工作内存中的值同步到主内存中
（4）一个新的变量只能在主内存中生成
（5）一个变量同一时刻只允许一条线程对其进行lock操作。但lock操作可以被同一条线程执行多次，只有执行相同次数的unlock操作，变量才会解锁
（6）如果对一个变量进行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或者assgin操作初始化变量的值。
（7）如果一个变量没有被锁定，不允许对其执行unlock操作，也不允许unlock一个被其他线程锁定的变量
（8）对一个变量执行unlock操作之前，需要将该变量同步回主内存中


8.jdk jre jvm三者之间的区别
https://blog.csdn.net/ancientear/article/details/79483592
https://www.cnblogs.com/yangming1996/p/8508187.html